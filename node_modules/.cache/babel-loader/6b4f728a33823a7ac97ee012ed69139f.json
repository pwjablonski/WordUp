{"ast":null,"code":"import { createLogic } from \"redux-logic\";\nimport { updateUI, updatePuzzle } from \"../actions\";\nimport { getCurrentCell, getCurrentDirection } from \"../selectors\";\nexport default createLogic({\n  type: \"KEY_INPUTTED\",\n\n  async process({\n    getState,\n    action: {\n      payload: {\n        key\n      }\n    }\n  }, dispatch, done) {\n    const state = getState();\n    const currentDirection = getCurrentDirection(state);\n    const currentCell = getCurrentCell(state);\n\n    switch (key) {\n      case \"ArrowDown\":\n        if (currentDirection === \"across\") {\n          dispatch(updateUI(currentCell, \"down\"));\n        } else if (currentCell < 210) {\n          dispatch(updateUI(currentCell + 15, currentDirection));\n        }\n\n        break;\n\n      case \"ArrowUp\":\n        if (currentDirection === \"across\") {\n          dispatch(updateUI(currentCell, \"down\"));\n        } else if (currentCell > 14) {\n          dispatch(updateUI(currentCell - 15, currentDirection));\n        }\n\n        break;\n\n      case \"ArrowRight\":\n        if (currentDirection === \"down\") {\n          dispatch(updateUI(currentCell, \"across\"));\n        } else if (currentCell < 224) {\n          dispatch(updateUI(currentCell + 1, currentDirection));\n        }\n\n        break;\n\n      case \"ArrowLeft\":\n        if (currentDirection === \"down\") {\n          dispatch(updateUI(currentCell, \"across\"));\n        } else if (currentCell > 0) {\n          dispatch(updateUI(currentCell - 1, currentDirection));\n        }\n\n        break;\n\n      case \"Backspace\":\n        {\n          let nextCell = currentCell;\n\n          if (currentCell > 0 && currentDirection === \"across\") {\n            nextCell -= 1;\n          }\n\n          if (currentCell > 14 && currentDirection === \"down\") {\n            nextCell -= 15;\n          }\n\n          await dispatch(updatePuzzle(\"\"));\n          dispatch(updateUI(nextCell, currentDirection));\n          break;\n        }\n\n      case \"Enter\":\n      case \"Tab\":\n        {\n          break;\n        }\n\n      case \"Control\":\n      case \"Alt\":\n      case \"Meta\":\n      case \"Escape\":\n      case \"Shift\":\n        {\n          break;\n        }\n\n      default:\n        {\n          let nextCell = currentCell;\n\n          if (currentCell < 224 && currentDirection === \"across\") {\n            nextCell += 1;\n          }\n\n          if (currentCell < 210 && currentDirection === \"down\") {\n            nextCell += 15;\n          }\n\n          await dispatch(updatePuzzle(key.toUpperCase()));\n          dispatch(updateUI(nextCell, currentDirection));\n          break;\n        }\n    }\n\n    done();\n  }\n\n});","map":{"version":3,"sources":["/Users/peter/Desktop/code/word-up/src/logic/keyInputted.js"],"names":["createLogic","updateUI","updatePuzzle","getCurrentCell","getCurrentDirection","type","process","getState","action","payload","key","dispatch","done","state","currentDirection","currentCell","nextCell","toUpperCase"],"mappings":"AAAA,SAASA,WAAT,QAA4B,aAA5B;AACA,SACEC,QADF,EAEEC,YAFF,QAGO,YAHP;AAIA,SACEC,cADF,EAEEC,mBAFF,QAGO,cAHP;AAKA,eAAeJ,WAAW,CAAC;AACzBK,EAAAA,IAAI,EAAE,cADmB;;AAEzB,QAAMC,OAAN,CACE;AACEC,IAAAA,QADF;AAEEC,IAAAA,MAAM,EAAE;AACNC,MAAAA,OAAO,EAAE;AAAEC,QAAAA;AAAF;AADH;AAFV,GADF,EAOEC,QAPF,EAQEC,IARF,EASE;AACA,UAAMC,KAAK,GAAGN,QAAQ,EAAtB;AACA,UAAMO,gBAAgB,GAAGV,mBAAmB,CAACS,KAAD,CAA5C;AACA,UAAME,WAAW,GAAGZ,cAAc,CAACU,KAAD,CAAlC;;AAEA,YAAQH,GAAR;AACE,WAAK,WAAL;AACI,YAAGI,gBAAgB,KAAK,QAAxB,EAAiC;AAC/BH,UAAAA,QAAQ,CAACV,QAAQ,CAACc,WAAD,EAAc,MAAd,CAAT,CAAR;AACD,SAFD,MAEO,IAAIA,WAAW,GAAG,GAAlB,EAAuB;AAC5BJ,UAAAA,QAAQ,CAACV,QAAQ,CAACc,WAAW,GAAG,EAAf,EAAmBD,gBAAnB,CAAT,CAAR;AACD;;AACD;;AACJ,WAAK,SAAL;AACE,YAAGA,gBAAgB,KAAK,QAAxB,EAAiC;AAC/BH,UAAAA,QAAQ,CAACV,QAAQ,CAACc,WAAD,EAAc,MAAd,CAAT,CAAR;AACD,SAFD,MAEO,IAAIA,WAAW,GAAG,EAAlB,EAAsB;AAC3BJ,UAAAA,QAAQ,CAACV,QAAQ,CAACc,WAAW,GAAG,EAAf,EAAmBD,gBAAnB,CAAT,CAAR;AACD;;AACD;;AACF,WAAK,YAAL;AACE,YAAGA,gBAAgB,KAAK,MAAxB,EAA+B;AAC7BH,UAAAA,QAAQ,CAACV,QAAQ,CAACc,WAAD,EAAc,QAAd,CAAT,CAAR;AACD,SAFD,MAEO,IAAIA,WAAW,GAAG,GAAlB,EAAuB;AAC5BJ,UAAAA,QAAQ,CAACV,QAAQ,CAACc,WAAW,GAAG,CAAf,EAAkBD,gBAAlB,CAAT,CAAR;AACD;;AACD;;AACF,WAAK,WAAL;AACE,YAAGA,gBAAgB,KAAK,MAAxB,EAA+B;AAC7BH,UAAAA,QAAQ,CAACV,QAAQ,CAACc,WAAD,EAAc,QAAd,CAAT,CAAR;AACD,SAFD,MAEO,IAAIA,WAAW,GAAG,CAAlB,EAAqB;AAC1BJ,UAAAA,QAAQ,CAACV,QAAQ,CAACc,WAAW,GAAG,CAAf,EAAkBD,gBAAlB,CAAT,CAAR;AACD;;AACD;;AACF,WAAK,WAAL;AAAkB;AAChB,cAAIE,QAAQ,GAAGD,WAAf;;AACA,cAAIA,WAAW,GAAG,CAAd,IAAmBD,gBAAgB,KAAK,QAA5C,EAAsD;AACpDE,YAAAA,QAAQ,IAAI,CAAZ;AACD;;AACD,cAAID,WAAW,GAAG,EAAd,IAAoBD,gBAAgB,KAAK,MAA7C,EAAqD;AACnDE,YAAAA,QAAQ,IAAI,EAAZ;AACD;;AACD,gBAAML,QAAQ,CAACT,YAAY,CAAC,EAAD,CAAb,CAAd;AACAS,UAAAA,QAAQ,CAACV,QAAQ,CAACe,QAAD,EAAWF,gBAAX,CAAT,CAAR;AACA;AACD;;AACD,WAAK,OAAL;AACA,WAAK,KAAL;AAAY;AAEV;AACD;;AACD,WAAK,SAAL;AACA,WAAK,KAAL;AACA,WAAK,MAAL;AACA,WAAK,QAAL;AACA,WAAK,OAAL;AAAc;AACZ;AACD;;AACD;AAAS;AACP,cAAIE,QAAQ,GAAGD,WAAf;;AACA,cAAIA,WAAW,GAAG,GAAd,IAAqBD,gBAAgB,KAAK,QAA9C,EAAwD;AACtDE,YAAAA,QAAQ,IAAI,CAAZ;AACD;;AACD,cAAID,WAAW,GAAG,GAAd,IAAqBD,gBAAgB,KAAK,MAA9C,EAAsD;AACpDE,YAAAA,QAAQ,IAAI,EAAZ;AACD;;AACD,gBAAML,QAAQ,CAACT,YAAY,CAACQ,GAAG,CAACO,WAAJ,EAAD,CAAb,CAAd;AACAN,UAAAA,QAAQ,CAACV,QAAQ,CAACe,QAAD,EAAWF,gBAAX,CAAT,CAAR;AACA;AACD;AAhEH;;AAkEAF,IAAAA,IAAI;AACL;;AAnFwB,CAAD,CAA1B","sourcesContent":["import { createLogic } from \"redux-logic\";\nimport {\n  updateUI,\n  updatePuzzle\n} from \"../actions\";\nimport {\n  getCurrentCell,\n  getCurrentDirection,\n} from \"../selectors\";\n\nexport default createLogic({\n  type: \"KEY_INPUTTED\",\n  async process(\n    {\n      getState,\n      action: {\n        payload: { key }\n      }\n    },\n    dispatch,\n    done\n  ) {\n    const state = getState();\n    const currentDirection = getCurrentDirection(state);\n    const currentCell = getCurrentCell(state);\n\n    switch (key) {\n      case \"ArrowDown\":\n          if(currentDirection === \"across\"){\n            dispatch(updateUI(currentCell, \"down\"))\n          } else if (currentCell < 210) {\n            dispatch(updateUI(currentCell + 15, currentDirection))\n          } \n          break;\n      case \"ArrowUp\":\n        if(currentDirection === \"across\"){\n          dispatch(updateUI(currentCell, \"down\"))\n        } else if (currentCell > 14) {\n          dispatch(updateUI(currentCell - 15, currentDirection))\n        } \n        break;\n      case \"ArrowRight\":\n        if(currentDirection === \"down\"){\n          dispatch(updateUI(currentCell, \"across\"))\n        } else if (currentCell < 224) {\n          dispatch(updateUI(currentCell + 1, currentDirection))\n        } \n        break;\n      case \"ArrowLeft\":\n        if(currentDirection === \"down\"){\n          dispatch(updateUI(currentCell, \"across\"))\n        } else if (currentCell > 0) {\n          dispatch(updateUI(currentCell - 1, currentDirection))\n        } \n        break;\n      case \"Backspace\": {\n        let nextCell = currentCell; \n        if (currentCell > 0 && currentDirection === \"across\") {\n          nextCell -= 1;  \n        } \n        if (currentCell > 14 && currentDirection === \"down\") {\n          nextCell -= 15;\n        }\n        await dispatch(updatePuzzle(\"\"));\n        dispatch(updateUI(nextCell, currentDirection))\n        break;\n      }\n      case \"Enter\":\n      case \"Tab\": {\n        \n        break;\n      }\n      case \"Control\":\n      case \"Alt\":\n      case \"Meta\":\n      case \"Escape\":\n      case \"Shift\": {\n        break;\n      }\n      default: {\n        let nextCell = currentCell; \n        if (currentCell < 224 && currentDirection === \"across\") {\n          nextCell += 1;\n        } \n        if (currentCell < 210 && currentDirection === \"down\") {\n          nextCell += 15;\n        } \n        await dispatch(updatePuzzle(key.toUpperCase()));\n        dispatch(updateUI(nextCell, currentDirection))\n        break;\n      }\n    }\n    done();\n  }\n});\n"]},"metadata":{},"sourceType":"module"}