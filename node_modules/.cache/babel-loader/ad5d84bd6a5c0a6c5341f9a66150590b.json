{"ast":null,"code":"import \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.function.name\";\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nimport { Observable, merge, asapScheduler } from 'rxjs';\nimport { debounceTime, filter, map, mergeMap, share, tap, throttleTime } from 'rxjs/operators';\nimport createLogicAction$ from './createLogicAction$';\nimport { identityFn } from './utils';\nimport createDispatch from './createDispatch';\nimport execProcessFn from './execProcessFn';\nimport createCancelled$ from './createCancelled$';\nimport createDepObject from './createDepObject';\nvar MATCH_ALL_TYPES = '*';\nexport default function logicWrapper(logic, store, deps, monitor$) {\n  var name = logic.name,\n      type = logic.type,\n      cancelType = logic.cancelType,\n      latest = logic.latest,\n      debounce = logic.debounce,\n      throttle = logic.throttle,\n      processFn = logic.process,\n      dispatchReturn = logic.processOptions.dispatchReturn;\n  var getState = store.getState; // cancel on cancelType or if take latest specified\n\n  var cancelTypes = [].concat(type && latest ? type : []).concat(cancelType || []);\n  return function wrappedLogic(actionIn$) {\n    // we want to share the same copy amongst all here\n    var action$ = actionIn$.pipe(share());\n    var cancel$ = cancelTypes.length ? action$.pipe(filter(function (action) {\n      return matchesType(cancelTypes, action.type);\n    })) : null;\n    var hasIntercept = logic.validate || logic.transform; // shortcut optimization if no intercept let action fall through\n    // and just exec the processFn\n\n    var mergeMapOrTap = hasIntercept ? mergeMap(function (action) {\n      return createLogicAction$({\n        action: action,\n        logic: logic,\n        store: store,\n        deps: deps,\n        cancel$: cancel$,\n        monitor$: monitor$,\n        action$: action$\n      });\n    }) : tap(function (action) {\n      // mimic the events as if went through createLogicAction$\n      // also in createLogicAction$\n      monitor$.next({\n        action: action,\n        name: name,\n        op: 'begin'\n      });\n      monitor$.next({\n        action: action,\n        nextAction: action,\n        name: name,\n        shouldProcess: true,\n        op: 'next'\n      });\n\n      var _createCancelled$ = createCancelled$({\n        action: action,\n        cancel$: cancel$,\n        monitor$: monitor$,\n        logic: logic\n      }),\n          cancelled$ = _createCancelled$.cancelled$,\n          setInterceptComplete = _createCancelled$.setInterceptComplete;\n\n      var _createDispatch = createDispatch({\n        action: action,\n        cancel$: cancel$,\n        cancelled$: cancelled$,\n        logic: logic,\n        monitor$: monitor$,\n        store: store\n      }),\n          dispatch = _createDispatch.dispatch,\n          dispatch$ = _createDispatch.dispatch$,\n          done = _createDispatch.done;\n\n      var ctx = {}; // no intercept, so empty ctx;\n\n      var depObj = createDepObject({\n        deps: deps,\n        cancelled$: cancelled$,\n        ctx: ctx,\n        getState: getState,\n        action: action,\n        action$: action$\n      });\n      asapScheduler.schedule(function () {\n        setInterceptComplete();\n        execProcessFn({\n          depObj: depObj,\n          dispatch: dispatch,\n          dispatch$: dispatch$,\n          dispatchReturn: dispatchReturn,\n          done: done,\n          name: name,\n          processFn: processFn\n        });\n      });\n    });\n    var matchingOps = [// operations to perform, falsey filtered out\n    filter(function (action) {\n      return matchesType(type, action.type);\n    }), debounce ? debounceTime(debounce) : null, throttle ? throttleTime(throttle) : null, mergeMapOrTap].filter(identityFn);\n    var matchingAction$ = action$.pipe.apply(action$, _toConsumableArray(matchingOps)); // shortcut optimization\n    // if type is match all '*', then no need to create other side of pipe\n\n    if (type === MATCH_ALL_TYPES) {\n      return matchingAction$;\n    } // types that don't match will bypass this logic\n\n\n    var nonMatchingAction$ = action$.pipe(filter(function (action) {\n      return !matchesType(type, action.type);\n    }));\n    return merge(nonMatchingAction$, matchingAction$);\n  };\n}\n\nfunction matchesType(tStrArrRe, type) {\n  /* istanbul ignore if  */\n  if (!tStrArrRe) {\n    return false;\n  } // nothing matches none\n\n\n  if (_typeof(tStrArrRe) === 'symbol') {\n    return tStrArrRe === type;\n  }\n\n  if (typeof tStrArrRe === 'string') {\n    return tStrArrRe === type || tStrArrRe === MATCH_ALL_TYPES;\n  }\n\n  if (Array.isArray(tStrArrRe)) {\n    return tStrArrRe.some(function (x) {\n      return matchesType(x, type);\n    });\n  } // else assume it is a RegExp\n\n\n  return tStrArrRe.test(type);\n}","map":null,"metadata":{},"sourceType":"module"}